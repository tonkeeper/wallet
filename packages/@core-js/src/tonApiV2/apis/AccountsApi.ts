/* tslint:disable */
/* eslint-disable */
/**
 * REST api to TON blockchain explorer
 * Provide access to indexed TON blockchain
 *
 * The version of the OpenAPI document: 2.0.0
 * Contact: support@tonkeeper.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import * as runtime from '../runtime';
import type {
  Account,
  AccountEvents,
  Accounts,
  DnsExpiring,
  DomainNames,
  FoundAccounts,
  GetAccountsRequest,
  GetBlockDefaultResponse,
  GetPublicKeyByAccountID200Response,
  JettonsBalances,
  NftItems,
  Subscriptions,
  TraceIds,
} from '../models/index';
import {
    AccountFromJSON,
    AccountToJSON,
    AccountEventsFromJSON,
    AccountEventsToJSON,
    AccountsFromJSON,
    AccountsToJSON,
    DnsExpiringFromJSON,
    DnsExpiringToJSON,
    DomainNamesFromJSON,
    DomainNamesToJSON,
    FoundAccountsFromJSON,
    FoundAccountsToJSON,
    GetAccountsRequestFromJSON,
    GetAccountsRequestToJSON,
    GetBlockDefaultResponseFromJSON,
    GetBlockDefaultResponseToJSON,
    GetPublicKeyByAccountID200ResponseFromJSON,
    GetPublicKeyByAccountID200ResponseToJSON,
    JettonsBalancesFromJSON,
    JettonsBalancesToJSON,
    NftItemsFromJSON,
    NftItemsToJSON,
    SubscriptionsFromJSON,
    SubscriptionsToJSON,
    TraceIdsFromJSON,
    TraceIdsToJSON,
} from '../models/index';

export interface DnsBackResolveRequest {
    accountId: string;
}

export interface GetAccountRequest {
    accountId: string;
}

export interface GetAccountsOperationRequest {
    getAccountsRequest?: GetAccountsRequest;
}

export interface GetDnsExpiringRequest {
    accountId: string;
    period?: number;
}

export interface GetEventsByAccountRequest {
    accountId: string;
    limit: number;
    acceptLanguage?: string;
    subjectOnly?: boolean;
    beforeLt?: number;
    startDate?: number;
    endDate?: number;
}

export interface GetJettonsBalancesRequest {
    accountId: string;
}

export interface GetJettonsHistoryRequest {
    accountId: string;
    limit: number;
    acceptLanguage?: string;
    beforeLt?: number;
    startDate?: number;
    endDate?: number;
}

export interface GetJettonsHistoryByIDRequest {
    accountId: string;
    jettonId: string;
    limit: number;
    acceptLanguage?: string;
    beforeLt?: number;
    startDate?: number;
    endDate?: number;
}

export interface GetNftItemsByOwnerRequest {
    accountId: string;
    collection?: string;
    limit?: number;
    offset?: number;
    indirectOwnership?: boolean;
}

export interface GetPublicKeyByAccountIDRequest {
    accountId: string;
}

export interface GetSearchAccountsRequest {
    name: string;
}

export interface GetSubscriptionsByAccountRequest {
    accountId: string;
}

export interface GetTracesByAccountRequest {
    accountId: string;
    limit?: number;
}

export interface ReindexAccountRequest {
    accountId: string;
}

/**
 * AccountsApi - interface
 * 
 * @export
 * @interface AccountsApiInterface
 */
export interface AccountsApiInterface {
    /**
     * Get domains for wallet account
     * @param {string} accountId account ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountsApiInterface
     */
    dnsBackResolveRaw(requestParameters: DnsBackResolveRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<DomainNames>>;

    /**
     * Get domains for wallet account
     */
    dnsBackResolve(requestParameters: DnsBackResolveRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<DomainNames>;

    /**
     * Get human-friendly information about an account without low-level details.
     * @param {string} accountId account ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountsApiInterface
     */
    getAccountRaw(requestParameters: GetAccountRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Account>>;

    /**
     * Get human-friendly information about an account without low-level details.
     */
    getAccount(requestParameters: GetAccountRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Account>;

    /**
     * Get human-friendly information about several accounts without low-level details.
     * @param {GetAccountsRequest} [getAccountsRequest] a list of account ids
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountsApiInterface
     */
    getAccountsRaw(requestParameters: GetAccountsOperationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Accounts>>;

    /**
     * Get human-friendly information about several accounts without low-level details.
     */
    getAccounts(requestParameters: GetAccountsOperationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Accounts>;

    /**
     * Get expiring .ton dns
     * @param {string} accountId account ID
     * @param {number} [period] number of days before expiration
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountsApiInterface
     */
    getDnsExpiringRaw(requestParameters: GetDnsExpiringRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<DnsExpiring>>;

    /**
     * Get expiring .ton dns
     */
    getDnsExpiring(requestParameters: GetDnsExpiringRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<DnsExpiring>;

    /**
     * Get events for an account. Each event is built on top of a trace which is a series of transactions caused by one inbound message. TonAPI looks for known patterns inside the trace and splits the trace into actions, where a single action represents a meaningful high-level operation like a Jetton Transfer or an NFT Purchase. Actions are expected to be shown to users. It is advised not to build any logic on top of actions because actions can be changed at any time.
     * @param {string} accountId account ID
     * @param {number} limit 
     * @param {string} [acceptLanguage] 
     * @param {boolean} [subjectOnly] filter actions where requested account is not real subject (for example sender or reciver jettons)
     * @param {number} [beforeLt] omit this parameter to get last events
     * @param {number} [startDate] 
     * @param {number} [endDate] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountsApiInterface
     */
    getEventsByAccountRaw(requestParameters: GetEventsByAccountRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<AccountEvents>>;

    /**
     * Get events for an account. Each event is built on top of a trace which is a series of transactions caused by one inbound message. TonAPI looks for known patterns inside the trace and splits the trace into actions, where a single action represents a meaningful high-level operation like a Jetton Transfer or an NFT Purchase. Actions are expected to be shown to users. It is advised not to build any logic on top of actions because actions can be changed at any time.
     */
    getEventsByAccount(requestParameters: GetEventsByAccountRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<AccountEvents>;

    /**
     * Get all Jettons balances by owner address
     * @param {string} accountId account ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountsApiInterface
     */
    getJettonsBalancesRaw(requestParameters: GetJettonsBalancesRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<JettonsBalances>>;

    /**
     * Get all Jettons balances by owner address
     */
    getJettonsBalances(requestParameters: GetJettonsBalancesRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<JettonsBalances>;

    /**
     * Get the transfer jettons history for account_id
     * @param {string} accountId account ID
     * @param {number} limit 
     * @param {string} [acceptLanguage] 
     * @param {number} [beforeLt] omit this parameter to get last events
     * @param {number} [startDate] 
     * @param {number} [endDate] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountsApiInterface
     */
    getJettonsHistoryRaw(requestParameters: GetJettonsHistoryRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<AccountEvents>>;

    /**
     * Get the transfer jettons history for account_id
     */
    getJettonsHistory(requestParameters: GetJettonsHistoryRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<AccountEvents>;

    /**
     * Get the transfer jetton history for account_id and jetton_id
     * @param {string} accountId account ID
     * @param {string} jettonId jetton ID
     * @param {number} limit 
     * @param {string} [acceptLanguage] 
     * @param {number} [beforeLt] omit this parameter to get last events
     * @param {number} [startDate] 
     * @param {number} [endDate] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountsApiInterface
     */
    getJettonsHistoryByIDRaw(requestParameters: GetJettonsHistoryByIDRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<AccountEvents>>;

    /**
     * Get the transfer jetton history for account_id and jetton_id
     */
    getJettonsHistoryByID(requestParameters: GetJettonsHistoryByIDRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<AccountEvents>;

    /**
     * Get all NFT items by owner address
     * @param {string} accountId account ID
     * @param {string} [collection] nft collection
     * @param {number} [limit] 
     * @param {number} [offset] 
     * @param {boolean} [indirectOwnership] Selling nft items in ton implemented usually via transfer items to special selling account. This option enables including items which owned not directly.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountsApiInterface
     */
    getNftItemsByOwnerRaw(requestParameters: GetNftItemsByOwnerRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<NftItems>>;

    /**
     * Get all NFT items by owner address
     */
    getNftItemsByOwner(requestParameters: GetNftItemsByOwnerRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<NftItems>;

    /**
     * Get public key by account id
     * @param {string} accountId account ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountsApiInterface
     */
    getPublicKeyByAccountIDRaw(requestParameters: GetPublicKeyByAccountIDRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<GetPublicKeyByAccountID200Response>>;

    /**
     * Get public key by account id
     */
    getPublicKeyByAccountID(requestParameters: GetPublicKeyByAccountIDRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<GetPublicKeyByAccountID200Response>;

    /**
     * Search for accounts by name. You can find the account by the first characters of the domain.
     * @param {string} name 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountsApiInterface
     */
    getSearchAccountsRaw(requestParameters: GetSearchAccountsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<FoundAccounts>>;

    /**
     * Search for accounts by name. You can find the account by the first characters of the domain.
     */
    getSearchAccounts(requestParameters: GetSearchAccountsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<FoundAccounts>;

    /**
     * Get all subscriptions by wallet address
     * @param {string} accountId account ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountsApiInterface
     */
    getSubscriptionsByAccountRaw(requestParameters: GetSubscriptionsByAccountRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Subscriptions>>;

    /**
     * Get all subscriptions by wallet address
     */
    getSubscriptionsByAccount(requestParameters: GetSubscriptionsByAccountRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Subscriptions>;

    /**
     * Get traces for account
     * @param {string} accountId account ID
     * @param {number} [limit] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountsApiInterface
     */
    getTracesByAccountRaw(requestParameters: GetTracesByAccountRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<TraceIds>>;

    /**
     * Get traces for account
     */
    getTracesByAccount(requestParameters: GetTracesByAccountRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<TraceIds>;

    /**
     * Update internal cache for a particular account
     * @param {string} accountId account ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountsApiInterface
     */
    reindexAccountRaw(requestParameters: ReindexAccountRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>>;

    /**
     * Update internal cache for a particular account
     */
    reindexAccount(requestParameters: ReindexAccountRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void>;

}

/**
 * 
 */
export class AccountsApi extends runtime.BaseAPI implements AccountsApiInterface {

    /**
     * Get domains for wallet account
     */
    async dnsBackResolveRaw(requestParameters: DnsBackResolveRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<DomainNames>> {
        if (requestParameters.accountId === null || requestParameters.accountId === undefined) {
            throw new runtime.RequiredError('accountId','Required parameter requestParameters.accountId was null or undefined when calling dnsBackResolve.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/v2/accounts/{account_id}/dns/backresolve`.replace(`{${"account_id"}}`, encodeURIComponent(String(requestParameters.accountId))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => DomainNamesFromJSON(jsonValue));
    }

    /**
     * Get domains for wallet account
     */
    async dnsBackResolve(requestParameters: DnsBackResolveRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<DomainNames> {
        const response = await this.dnsBackResolveRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Get human-friendly information about an account without low-level details.
     */
    async getAccountRaw(requestParameters: GetAccountRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Account>> {
        if (requestParameters.accountId === null || requestParameters.accountId === undefined) {
            throw new runtime.RequiredError('accountId','Required parameter requestParameters.accountId was null or undefined when calling getAccount.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/v2/accounts/{account_id}`.replace(`{${"account_id"}}`, encodeURIComponent(String(requestParameters.accountId))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => AccountFromJSON(jsonValue));
    }

    /**
     * Get human-friendly information about an account without low-level details.
     */
    async getAccount(requestParameters: GetAccountRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Account> {
        const response = await this.getAccountRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Get human-friendly information about several accounts without low-level details.
     */
    async getAccountsRaw(requestParameters: GetAccountsOperationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Accounts>> {
        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        const response = await this.request({
            path: `/v2/accounts/_bulk`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: GetAccountsRequestToJSON(requestParameters.getAccountsRequest),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => AccountsFromJSON(jsonValue));
    }

    /**
     * Get human-friendly information about several accounts without low-level details.
     */
    async getAccounts(requestParameters: GetAccountsOperationRequest = {}, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Accounts> {
        const response = await this.getAccountsRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Get expiring .ton dns
     */
    async getDnsExpiringRaw(requestParameters: GetDnsExpiringRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<DnsExpiring>> {
        if (requestParameters.accountId === null || requestParameters.accountId === undefined) {
            throw new runtime.RequiredError('accountId','Required parameter requestParameters.accountId was null or undefined when calling getDnsExpiring.');
        }

        const queryParameters: any = {};

        if (requestParameters.period !== undefined) {
            queryParameters['period'] = requestParameters.period;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/v2/accounts/{account_id}/dns/expiring`.replace(`{${"account_id"}}`, encodeURIComponent(String(requestParameters.accountId))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => DnsExpiringFromJSON(jsonValue));
    }

    /**
     * Get expiring .ton dns
     */
    async getDnsExpiring(requestParameters: GetDnsExpiringRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<DnsExpiring> {
        const response = await this.getDnsExpiringRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Get events for an account. Each event is built on top of a trace which is a series of transactions caused by one inbound message. TonAPI looks for known patterns inside the trace and splits the trace into actions, where a single action represents a meaningful high-level operation like a Jetton Transfer or an NFT Purchase. Actions are expected to be shown to users. It is advised not to build any logic on top of actions because actions can be changed at any time.
     */
    async getEventsByAccountRaw(requestParameters: GetEventsByAccountRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<AccountEvents>> {
        if (requestParameters.accountId === null || requestParameters.accountId === undefined) {
            throw new runtime.RequiredError('accountId','Required parameter requestParameters.accountId was null or undefined when calling getEventsByAccount.');
        }

        if (requestParameters.limit === null || requestParameters.limit === undefined) {
            throw new runtime.RequiredError('limit','Required parameter requestParameters.limit was null or undefined when calling getEventsByAccount.');
        }

        const queryParameters: any = {};

        if (requestParameters.subjectOnly !== undefined) {
            queryParameters['subject_only'] = requestParameters.subjectOnly;
        }

        if (requestParameters.beforeLt !== undefined) {
            queryParameters['before_lt'] = requestParameters.beforeLt;
        }

        if (requestParameters.limit !== undefined) {
            queryParameters['limit'] = requestParameters.limit;
        }

        if (requestParameters.startDate !== undefined) {
            queryParameters['start_date'] = requestParameters.startDate;
        }

        if (requestParameters.endDate !== undefined) {
            queryParameters['end_date'] = requestParameters.endDate;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (requestParameters.acceptLanguage !== undefined && requestParameters.acceptLanguage !== null) {
            headerParameters['Accept-Language'] = String(requestParameters.acceptLanguage);
        }

        const response = await this.request({
            path: `/v2/accounts/{account_id}/events`.replace(`{${"account_id"}}`, encodeURIComponent(String(requestParameters.accountId))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => AccountEventsFromJSON(jsonValue));
    }

    /**
     * Get events for an account. Each event is built on top of a trace which is a series of transactions caused by one inbound message. TonAPI looks for known patterns inside the trace and splits the trace into actions, where a single action represents a meaningful high-level operation like a Jetton Transfer or an NFT Purchase. Actions are expected to be shown to users. It is advised not to build any logic on top of actions because actions can be changed at any time.
     */
    async getEventsByAccount(requestParameters: GetEventsByAccountRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<AccountEvents> {
        const response = await this.getEventsByAccountRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Get all Jettons balances by owner address
     */
    async getJettonsBalancesRaw(requestParameters: GetJettonsBalancesRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<JettonsBalances>> {
        if (requestParameters.accountId === null || requestParameters.accountId === undefined) {
            throw new runtime.RequiredError('accountId','Required parameter requestParameters.accountId was null or undefined when calling getJettonsBalances.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/v2/accounts/{account_id}/jettons`.replace(`{${"account_id"}}`, encodeURIComponent(String(requestParameters.accountId))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => JettonsBalancesFromJSON(jsonValue));
    }

    /**
     * Get all Jettons balances by owner address
     */
    async getJettonsBalances(requestParameters: GetJettonsBalancesRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<JettonsBalances> {
        const response = await this.getJettonsBalancesRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Get the transfer jettons history for account_id
     */
    async getJettonsHistoryRaw(requestParameters: GetJettonsHistoryRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<AccountEvents>> {
        if (requestParameters.accountId === null || requestParameters.accountId === undefined) {
            throw new runtime.RequiredError('accountId','Required parameter requestParameters.accountId was null or undefined when calling getJettonsHistory.');
        }

        if (requestParameters.limit === null || requestParameters.limit === undefined) {
            throw new runtime.RequiredError('limit','Required parameter requestParameters.limit was null or undefined when calling getJettonsHistory.');
        }

        const queryParameters: any = {};

        if (requestParameters.beforeLt !== undefined) {
            queryParameters['before_lt'] = requestParameters.beforeLt;
        }

        if (requestParameters.limit !== undefined) {
            queryParameters['limit'] = requestParameters.limit;
        }

        if (requestParameters.startDate !== undefined) {
            queryParameters['start_date'] = requestParameters.startDate;
        }

        if (requestParameters.endDate !== undefined) {
            queryParameters['end_date'] = requestParameters.endDate;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (requestParameters.acceptLanguage !== undefined && requestParameters.acceptLanguage !== null) {
            headerParameters['Accept-Language'] = String(requestParameters.acceptLanguage);
        }

        const response = await this.request({
            path: `/v2/accounts/{account_id}/jettons/history`.replace(`{${"account_id"}}`, encodeURIComponent(String(requestParameters.accountId))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => AccountEventsFromJSON(jsonValue));
    }

    /**
     * Get the transfer jettons history for account_id
     */
    async getJettonsHistory(requestParameters: GetJettonsHistoryRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<AccountEvents> {
        const response = await this.getJettonsHistoryRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Get the transfer jetton history for account_id and jetton_id
     */
    async getJettonsHistoryByIDRaw(requestParameters: GetJettonsHistoryByIDRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<AccountEvents>> {
        if (requestParameters.accountId === null || requestParameters.accountId === undefined) {
            throw new runtime.RequiredError('accountId','Required parameter requestParameters.accountId was null or undefined when calling getJettonsHistoryByID.');
        }

        if (requestParameters.jettonId === null || requestParameters.jettonId === undefined) {
            throw new runtime.RequiredError('jettonId','Required parameter requestParameters.jettonId was null or undefined when calling getJettonsHistoryByID.');
        }

        if (requestParameters.limit === null || requestParameters.limit === undefined) {
            throw new runtime.RequiredError('limit','Required parameter requestParameters.limit was null or undefined when calling getJettonsHistoryByID.');
        }

        const queryParameters: any = {};

        if (requestParameters.beforeLt !== undefined) {
            queryParameters['before_lt'] = requestParameters.beforeLt;
        }

        if (requestParameters.limit !== undefined) {
            queryParameters['limit'] = requestParameters.limit;
        }

        if (requestParameters.startDate !== undefined) {
            queryParameters['start_date'] = requestParameters.startDate;
        }

        if (requestParameters.endDate !== undefined) {
            queryParameters['end_date'] = requestParameters.endDate;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (requestParameters.acceptLanguage !== undefined && requestParameters.acceptLanguage !== null) {
            headerParameters['Accept-Language'] = String(requestParameters.acceptLanguage);
        }

        const response = await this.request({
            path: `/v2/accounts/{account_id}/jettons/{jetton_id}/history`.replace(`{${"account_id"}}`, encodeURIComponent(String(requestParameters.accountId))).replace(`{${"jetton_id"}}`, encodeURIComponent(String(requestParameters.jettonId))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => AccountEventsFromJSON(jsonValue));
    }

    /**
     * Get the transfer jetton history for account_id and jetton_id
     */
    async getJettonsHistoryByID(requestParameters: GetJettonsHistoryByIDRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<AccountEvents> {
        const response = await this.getJettonsHistoryByIDRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Get all NFT items by owner address
     */
    async getNftItemsByOwnerRaw(requestParameters: GetNftItemsByOwnerRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<NftItems>> {
        if (requestParameters.accountId === null || requestParameters.accountId === undefined) {
            throw new runtime.RequiredError('accountId','Required parameter requestParameters.accountId was null or undefined when calling getNftItemsByOwner.');
        }

        const queryParameters: any = {};

        if (requestParameters.collection !== undefined) {
            queryParameters['collection'] = requestParameters.collection;
        }

        if (requestParameters.limit !== undefined) {
            queryParameters['limit'] = requestParameters.limit;
        }

        if (requestParameters.offset !== undefined) {
            queryParameters['offset'] = requestParameters.offset;
        }

        if (requestParameters.indirectOwnership !== undefined) {
            queryParameters['indirect_ownership'] = requestParameters.indirectOwnership;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/v2/accounts/{account_id}/nfts`.replace(`{${"account_id"}}`, encodeURIComponent(String(requestParameters.accountId))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => NftItemsFromJSON(jsonValue));
    }

    /**
     * Get all NFT items by owner address
     */
    async getNftItemsByOwner(requestParameters: GetNftItemsByOwnerRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<NftItems> {
        const response = await this.getNftItemsByOwnerRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Get public key by account id
     */
    async getPublicKeyByAccountIDRaw(requestParameters: GetPublicKeyByAccountIDRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<GetPublicKeyByAccountID200Response>> {
        if (requestParameters.accountId === null || requestParameters.accountId === undefined) {
            throw new runtime.RequiredError('accountId','Required parameter requestParameters.accountId was null or undefined when calling getPublicKeyByAccountID.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/v2/accounts/{account_id}/publickey`.replace(`{${"account_id"}}`, encodeURIComponent(String(requestParameters.accountId))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => GetPublicKeyByAccountID200ResponseFromJSON(jsonValue));
    }

    /**
     * Get public key by account id
     */
    async getPublicKeyByAccountID(requestParameters: GetPublicKeyByAccountIDRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<GetPublicKeyByAccountID200Response> {
        const response = await this.getPublicKeyByAccountIDRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Search for accounts by name. You can find the account by the first characters of the domain.
     */
    async getSearchAccountsRaw(requestParameters: GetSearchAccountsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<FoundAccounts>> {
        if (requestParameters.name === null || requestParameters.name === undefined) {
            throw new runtime.RequiredError('name','Required parameter requestParameters.name was null or undefined when calling getSearchAccounts.');
        }

        const queryParameters: any = {};

        if (requestParameters.name !== undefined) {
            queryParameters['name'] = requestParameters.name;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/v2/accounts/search`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => FoundAccountsFromJSON(jsonValue));
    }

    /**
     * Search for accounts by name. You can find the account by the first characters of the domain.
     */
    async getSearchAccounts(requestParameters: GetSearchAccountsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<FoundAccounts> {
        const response = await this.getSearchAccountsRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Get all subscriptions by wallet address
     */
    async getSubscriptionsByAccountRaw(requestParameters: GetSubscriptionsByAccountRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Subscriptions>> {
        if (requestParameters.accountId === null || requestParameters.accountId === undefined) {
            throw new runtime.RequiredError('accountId','Required parameter requestParameters.accountId was null or undefined when calling getSubscriptionsByAccount.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/v2/accounts/{account_id}/subscriptions`.replace(`{${"account_id"}}`, encodeURIComponent(String(requestParameters.accountId))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => SubscriptionsFromJSON(jsonValue));
    }

    /**
     * Get all subscriptions by wallet address
     */
    async getSubscriptionsByAccount(requestParameters: GetSubscriptionsByAccountRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Subscriptions> {
        const response = await this.getSubscriptionsByAccountRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Get traces for account
     */
    async getTracesByAccountRaw(requestParameters: GetTracesByAccountRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<TraceIds>> {
        if (requestParameters.accountId === null || requestParameters.accountId === undefined) {
            throw new runtime.RequiredError('accountId','Required parameter requestParameters.accountId was null or undefined when calling getTracesByAccount.');
        }

        const queryParameters: any = {};

        if (requestParameters.limit !== undefined) {
            queryParameters['limit'] = requestParameters.limit;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/v2/accounts/{account_id}/traces`.replace(`{${"account_id"}}`, encodeURIComponent(String(requestParameters.accountId))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => TraceIdsFromJSON(jsonValue));
    }

    /**
     * Get traces for account
     */
    async getTracesByAccount(requestParameters: GetTracesByAccountRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<TraceIds> {
        const response = await this.getTracesByAccountRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Update internal cache for a particular account
     */
    async reindexAccountRaw(requestParameters: ReindexAccountRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>> {
        if (requestParameters.accountId === null || requestParameters.accountId === undefined) {
            throw new runtime.RequiredError('accountId','Required parameter requestParameters.accountId was null or undefined when calling reindexAccount.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/v2/accounts/{account_id}/reindex`.replace(`{${"account_id"}}`, encodeURIComponent(String(requestParameters.accountId))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     * Update internal cache for a particular account
     */
    async reindexAccount(requestParameters: ReindexAccountRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void> {
        await this.reindexAccountRaw(requestParameters, initOverrides);
    }

}
